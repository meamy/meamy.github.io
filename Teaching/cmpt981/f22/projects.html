<!DOCTYPE html>

<head>
  <title>CMPT 409/981: Quantum Circuits and Compilation</title>
  <link rel="stylesheet" href="../../style.css" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Spectral&display=swap" rel="stylesheet">
  <meta name="author" content="Matt Amy">
  <meta name="keywords" content="Matthew Amy, quantum programming, quantum circuits">
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
  </script>
  <script type="text/javascript"
          src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
</head>

<body>
  <div class="course">
    <h1>CMPT 409/981 project</h1>
    <h2>Project overview</h3><hr>
    <br>
    For the course project you are asked to do your own independent research on a topic in quantum circuits and compilation. The only specific requirement for the project is a written report. <b>You may work in groups of up to two (2)</b>
    
    <br><br> Broadly speaking, the project may take one of a few forms:
    <h3>Option 1: Coding</h3>
    For a coding-style project, you should implement some non-trivial compilation/optimization/verification/etc. algorithm(s). They can be algorithm(s) we've seen in class or in papers, and they can be implemented inside existing compilers/software packages (listed below) or free-form. The main requirement here is that it is your own work, i.e. you are not simply copy and pasting some existing compilation code from Qiskit.
    
    If you do a coding style project, your report should detail your implementation, any challenges or issues that arose, and some experimental results. For example, you may choose to compare two different compilation algorithms, or compare your implementation against another existing implementation. Benchmark circuits can be found, for example, in the Feynman repository listed below.
    <br><br>
    
    Here is a (non-exhaustive) list of software packages which may be of use:
    <ul>
    	<li><a href="https://qiskit.org/">Qiskit</a> - IBM's quantum software mega-suite</li>
    	<li><a href="https://github.com/Quantomatic/pyzx">PyZX</a> - Python compilation package for working with ZX diagrams</li>
    	<li><a href="https://www.mathstat.dal.ca/~selinger/quipper/">Quipper</a> - Compiler for the Quipper DSL written in Haskell</li>
    	<li><a href="https://hackage.haskell.org/package/newsynth">newsynth</a> - package that broke off from Quipper implementing number-theoretic synthesis</li>
    	<li><a href="https://github.com/iic-jku/jkq">JKQ</a> A collection of C++ tools for quantum circuits & compilation built around the quantum decision diagram representation</li>
    	<li><a href="https://github.com/quil-lang/quilc">QuilC</a> - Compiler for the Quil instruction set written in Lisp</li>
    	<li><a href="https://github.com/meamy/feynman">Feynman</a> - Haskell compilation package implementing the sum-over-paths. <b>Also includes a useful suite of benchmark circuits in two formats.</b></li>
    	<li><a href="https://github.com/softwareQinc/staq">staq</a> - C++-based compiler/transpiler for openQASM 2</li>
    	<li><a href="https://github.com/inQWIRE">inQWIRE</a> - Various compilers, libraries and languages for writing and compiling formally verified quantum code in coq</li>
    	<li><a href="https://strawberryfields.ai/">Strawberry Fields</a> - Python based library for photonic quantum computation</li>
    </ul>
    
    <h3>Option 2: Theory</h3>
    Select a topic and read one or more papers on it then write a report. A typical format would be to survey a few different methods for a particular problem in compilation, e.g. different optimization algorithms, and write a comparative analysis. Where does one method particularly shine? Are there any trade-offs or is one method clearly superior? Are they complementary in that their combination can be used to solve a larger problem? If you choose to do a report on a single paper, your report should clearly explain the details of the work and provide some new insight and criticism. In the end the depth of the analysis of each paper should roughly be inversely proportional to the number of papers you are reading.<br> <br>
    
    Some samples (slightly out of the course scope) are provided <a href="Sample 1.pdf">here</a> and <a href="Sample 2.pdf">here</a>. This should be a more in depth report (around 10 pages) than if the project is largely coding based. 
    
    <h3>Option 3: Application</h3>
    Apply compilation techniques to solve a problem, possibly related to your own research. An example could be to compile a non-trivial instance of a quantum algorithm down to Clifford+T --- e.g. simulation of the ground state energy of a particular molecule using phase estimation, or an instance of Grover's search applied to SAT solving. You will likely need to read papers to fill in gaps in your knowledge on the algorithmic side.
   
    <h2>Deadlines</h3><hr>
    <br>
    <ul>
    	<li> <b>November 10th</b>: Propose your project idea to the instructor</li>
    	<li> <b>December 11th</b>: Deadline to hand in your project</li>
    </ul>
    
    <h2>Resources</h3><hr>
    <br>
    <a href="Project template.tex">Template</a> for writing your report in LaTeX (not required but recommended)

    <h2>Possible projects</h3><hr>
    <br>
    <ul>
    	<li> <b>Compilation algorithm implementation</b><br> Choose (1) optimization/compilation algorithm (e.g. from the <a href="readings.html">reading list</a>) and (1) software package that doesn't already implement that algorithm, then implement that algorithm in that software package. Examples include <a href="https://arxiv.org/abs/1712.01557">T-opt</a> or <a href="https://arxiv.org/abs/1403.2975">Gridsynth</a> in Qiskit. Bonus points for making a pull request at the end.</li>
    	<li> <b>Linear reversible synthesis</b><br><a href="https://www.sciencedirect.com/science/article/pii/S0196885807000711">On the complexity of matrix reduction over finite fields</a> gives an algorithm for fast Gaussian elimination in finite fields such as $\mathbb{Z}_2$, which can be used to synthesize linear reversible (i.e. CNOT only) circuits. Implement and compare this to the Patel-Markov-Hayes algorithm (<a href="https://dl.acm.org/doi/10.5555/2011763.2011767"> Optimal synthesis of linear reversible circuits</a>) and/or more recent work such as <a href="https://arxiv.org/abs/2201.06508">Gaussian Elimination versus Greedy Methods for the Synthesis of Linear Reversible Circuits</a>.</li>
    	<li> <b>Resource estimation</b><br>Compile an instance of some quantum algorithm applied to some specific problem (e.g. <a href="https://arxiv.org/abs/1909.12658">quantum algorithm for finding the optimal variable ordering in a binary decision diagram</a>) to be executed on fault-tolerant hardware (i.e. compile to Clifford+T). Estimate the amount of space, circuit depth, number of each type of gate, etc. as a function of the input size.</li>
    	<li> <b>Toy problem</b><br>Pick (1) NP complete problem and (1) quantum circuit toolkit (e.g. Qiskit) and implement a compilation routine to take an arbitrary instance of that NP complete problem and compile an instance of QAOA solving it. Run some experiments simulating the resulting circuit on some toy sizes. Bonus points for running on real quantum hardware. <b>Note: there should not already be a compilation routine in the given toolkit for this problem.</b> For example, Pennylane has an <a href="https://pennylane.ai/qml/demos/tutorial_qaoa_intro.html">existing routine</a> for compiling an QAOA instance solving Vertex Cover.</li>
    	<li> <b>Lower bounds (research problem)</b><br> Extend the dyadic monotone from <a href="https://arxiv.org/abs/1904.01124">Lower bounds on the non-Clifford resources for quantum computations</a> to unitaries, as was done with the stabilizer nullity in <a href="https://arxiv.org/abs/2103.09999">Lower bound the T-count via unitary stabilizer nullity</a> and see if it gives any improved lower bounds.</li>
    	<li> <b>Compiler frontend</b><br> Write a compiler frontend for (a subset of) Q# or some other high-level quantum programming language and compile down to an intermediate representation such as openQASM 2/3 or QIR. As in the classical case, the use of languages like openQASM or QIR as intermediate representations allows developers to solve the "N-to-M" problem of writing a compiler for every combination of high-level language and individual hardware platform.</li>
    	<li> <b>Template-based circuit optimizer</b><br>Implement a template-based circuit optimizer using a <b>complete</b> re-writing theory (e.g. <a href="https://arxiv.org/abs/2206.10577">A Complete Equational Theory for Quantum Circuits</a>, <a href="https://arxiv.org/abs/1310.6813">Generators and relations for n-qubit Clifford operators</a>, <a href="https://arxiv.org/abs/2204.02217">Generators and relations for 2-qubit Clifford+T operators</a>). A complete re-writing theory means that whenever two circuits are equal as unitaries, one can be re-written to the other using only rules in the theory.</li>
    	<li> <b>Verification</b><br> Use a circuit verification package (e.g. JKQ or Feynman) to write a static assertion checker for the <a href="https://silq.ethz.ch/">Silq</a> or <a href="https://dl.acm.org/doi/abs/10.1145/3498691">Twist</a> language.</li>
    	<li> <b>Quantum arithmetic</b><br> Write an openQASM 3 library for reversible arithmetic (e.g. multipliers, adders, exponentiation) on qubit registers of <b>arbitrary width</b>. That is, program circuit <b>families</b> for arithmetic operations in the openQASM 3 circuit language. Note: this was impossible in openQASM 2 because qubit registers had statically fixed sizes.</li>
    	<li> <b>Braided surface code compilation</b><br> Implement a braided surface code compiler using the modular presentation of surface code braiding from <a href="https://www.jstage.jst.go.jp/article/transfun/E102.A/4/E102.A_624/_article">Compaction of Topological Quantum Circuits by Modularization</a>.</li>
    	<li> <b>Readings</b><br> Pick 2-4 papers in one topic (e.g. from the <a href="readings.html">readings list</a>) and write a report synthesizing and comparing them.</li>
    </ul>
    
    Please ask me to expand on any of these if you're interested but unsure of the details.
  </div>
</body>
